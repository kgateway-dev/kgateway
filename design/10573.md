# EP-10573: AWS Lambda Integration

* Issue: [#10573](https://github.com/kgateway-dev/kgateway/issues/10573)

## Background

The Gateway API has become a standard for routing traffic within Kubernetes clusters, primarily supporting native resources like `HTTPRoute` and `TCPRoute` to direct traffic to Kubernetes Services. However, organizations adopting serverless architectures increasingly rely on AWS Lambda as a compute backend, which the Gateway API does not natively support.

Kgateway fills this gap through its custom `Upstream` API, designed as an extension point to support a broad range of destinations, including static hosts and AWS Lambda functions. This enhancement introduces native AWS Lambda integration into kgateway’s routing capabilities, enabling users to maintain a consistent Gateway API experience while seamlessly integrating serverless backends.

Furthermore, this proposal moves away from the previous approach that relied on a custom envoy-gloo lambda filter and the synthetic `Parameter` GVK. Instead, it leverages Envoy’s built-in AWS Lambda filter and expands the existing `RoutePolicy` API to support function-level configuration. By clearly separating connection-level concerns (via the `Upstream` API) from function-specific routing (via the `RoutePolicy` API), the design enhances composability and simplifies configuration—users no longer need to create a new `Upstream` resource for each Lambda function.

## Motivation

Organizations adopting serverless architectures face unique challenges when integrating Gateway API implementations. While the HTTPRoute API is excellent for routing to Kubernetes services, it lacks built-in support for the nuances of AWS Lambda—including managing function versions, controlling invocation modes, and handling cross-account access.

This enhancement aims to deliver a unified and open API experience that supports both traditional Kubernetes services and serverless functions. Key motivations include:

- **Composability**: Developers can iterate on function versions and aliases without having to reconfigure underlying connection details.
- **Flexibility**: The explicit RoutePolicy API allows users to control whether Lambda functions are invoked synchronously or asynchronously.
- **Security**: Security teams gain fine-grained control over AWS credential management and cross-account access patterns.
- **Maintainability**: By replacing the custom Envoy filter and implicit configuration model with Envoy’s native Lambda support and clear API boundaries, the solution becomes more maintainable and scalable.

In summary, this enhancement not only extends the capabilities of kgateway to support AWS Lambda but also streamlines the overall configuration model, helping organizations adopt serverless technologies without compromising on the core benefits of the Gateway API.

### Goals

- Enable users to route traffic to AWS Lambda backends.
- Replace the envoy-gloo lambda filter with the upstream Envoy AWS-related filter(s).
- Initial support for secure AWS credential management.
- Support for Lambda function qualifiers and versioning.
- Support for Lambda function invocation mode (sync/async).

### Non-Goals

- Supporting other serverless platforms (e.g., Azure Functions, Google Cloud Functions).
- Support for all authentication methods (e.g. IRSA, web identity token, STS token exchange, etc.). This can be done in the future if needed.
- Support for cross-account function invocation. This can be done in the future if needed.
- Any request or response transformations. This can be done in the future if needed.

## Implementation Details

This proposal is focused on extending the Upstream and RoutePolicy APIs to support routing to AWS Lambda functions. Additionally, it proposes moving away from the custom envoy-gloo lambda filter and the synthetic `Parameter` GVK approach. The following sub-sections detail the API changes, example configurations, and dive into the lower-level details like the plugin implementation.

### API Changes

#### Upstream

The upstream_policy_types.go file will be updated to add the new AWS Lambda-specific configuration:

```go
const (
	// UpstreamTypeAws is the type of upstream that references an AWS Lambda function.
	UpstreamTypeAws = "aws"
	// UpstreamTypeStatic is the type of upstream that references a static list of hosts.
	UpstreamTypeStatic = "static"
)

// UpstreamSpec defines the desired state of an Upstream.
// +kubebuilder:validation:XValidation:message="Type field must match the upstream configuration: aws requires Aws field, static requires Static field",rule="(self.type == 'aws' && has(self.aws) && !has(self.static)) || (self.type == 'static' && has(self.static) && !has(self.aws))"
type UpstreamSpec struct {
	// Type controls the type of upstream.
	// +unionDiscriminator
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Enum=aws;static
	Type string `json:"type"`
	// AWS upstream configuration. Allows for referencing AWS Lambda functions.
	// +optional
	Aws *AwsUpstream `json:"aws,omitempty"`
	// Static upstream configuration. Allows for referencing a list of hosts.
	// +optional
	Static *StaticUpstream `json:"static,omitempty"`
}

const (
	// AwsCrossAccountModeResourceBased is the cross-account mode for resource-based Lambda invocations.
	AwsCrossAccountModeResourceBased = "RESOURCE_BASED"
	// AwsCrossAccountModeRoleChaining is the cross-account mode for role-chaining Lambda invocations.
	AwsCrossAccountModeRoleChaining = "ROLE_CHAINING"
)

// AwsUpstream is an upstream that configures AWS Lambda functionality.
type AwsUpstream struct {
	// Region is the AWS region to use for the upstream.
	// +kubebuilder:validation:Required
	Region string `json:"region"`
	// AccountId is the AWS account ID to use for the upstream.
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern=^[0-9]{12}$
	AccountId string `json:"accountId"`
	// Auth specifies the authentication method to use for the upstream.
	// +kubebuilder:validation:Required
	// +required
	Auth *AwsAuth `json:"auth"`
	// EndpointURL is the URL to use for the upstream host. Defaults
	// to the AWS lambda endpoint when not provided. This is useful
	// for testing with a local lambda function.
	// +optional
	EndpointURL string `json:"endpointURL,omitempty"`
	// CrossAccountMode defines how to handle cross-account Lambda invocations.
	// Defaults to RESOURCE_BASED if not specified.
  // Note(tim): This is a strawman for now. We may not want to support this unless it's a strict requirement.
	// +optional
	// +kubebuilder:validation:Enum=RESOURCE_BASED;ROLE_CHAINING
	CrossAccountMode string `json:"crossAccountMode,omitempty"`
}

// AwsAuth defines the authentication method to use for the upstream.
type AwsAuth struct {
	// Secret is a reference to a secret containing AWS credentials.
	// +optional
	Secret *SecretReference `json:"secret,omitempty"`
}

// SecretReference is a reference to a secret containing AWS credentials.
type SecretReference struct {
	// Name is the name of the secret.
	// +kubebuilder:validation:Required
	Name string `json:"name,omitempty"`
	// Namespace is the namespace of the secret. If omitted, the secret
	// is assumed to be in the same namespace as the upstream.
	// +optional
	Namespace string `json:"namespace,omitempty"`
}
```

#### RoutePolicy

The route_policy_types.go file will be updated to add the new AWS Lambda-specific configuration:

```go
// RoutePolicySpec defines the desired state of a RoutePolicy.
type RoutePolicySpec struct {
	// TargetRef specifies the target resource for the policy.
	TargetRef LocalPolicyTargetReference `json:"targetRef,omitempty"`
	// Timeout is the timeout in seconds for the route policy.
	// +kubebuilder:validation:Minimum=1
	Timeout int `json:"timeout,omitempty"`
	// Lambda configuration details for AWS Lambda invocations.
	// +optional
	Lambda *LambdaConfig `json:"lambda,omitempty"`
}

const (
	// RoutePolicyInvocationModeSync is the invocation mode for synchronous Lambda invocations.
	RoutePolicyInvocationModeSync = "Sync"
	// RoutePolicyInvocationModeAsync is the invocation mode for asynchronous Lambda invocations.
	RoutePolicyInvocationModeAsync = "Async"
)

// LambdaConfig defines AWS Lambda-specific configuration for route policies.
type LambdaConfig struct {
	// FunctionName is the name of the Lambda function to invoke.
	// +kubebuilder:validation:Required
	FunctionName string `json:"functionName"`
	// Qualifier is an optional qualifier for the Lambda function.
	// Can be a version number or alias name. Defaults to $LATEST if not provided.
	// +optional
	// +kubebuilder:validation:MaxLength=128
	Qualifier string `json:"qualifier,omitempty"`
	// InvocationMode indicates whether the Lambda function should be invoked
	// synchronously or asynchronously. Defaults to Sync if not provided.
	// In Async mode, the gateway will not wait for the function response.
	// +optional
	// +kubebuilder:validation:Enum=Sync;Async
	InvocationMode string `json:"invocationMode,omitempty"`
}
```

### Configuration

Let's go through an example of how to configure an AWS Lambda function as an upstream and a route policy.

#### Upstream

```yaml
---
apiVersion: gateway.kgateway.dev/v1alpha1
kind: Upstream
metadata:
  name: my-lambda-upstream
  namespace: kgateway-system
spec:
  type: aws
  aws:
    accountId: "000000000000"
    region: us-west-2
    auth:
      secret:
        name: aws-creds
        namespace: kgateway-system
```

#### Route Policy

```yaml
---
apiVersion: gateway.kgateway.dev/v1alpha1
kind: RoutePolicy
metadata:
  name: my-prod-lambda-function
  namespace: kgateway-system
spec:
  lambda:
    functionName: my-lambda-function
    qualifier: prod
    invocationMode: Async
---
apiVersion: gateway.kgateway.dev/v1alpha1
kind: RoutePolicy
metadata:
  name: my-dev-lambda-function
  namespace: kgateway-system
spec:
  lambda:
    functionName: my-lambda-function
    qualifier: dev
```

#### HTTPRoute

```yaml
---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: example-route
  namespace: kgateway-system
  labels:
    app: example-app
spec:
  hostnames:
  - "www.example.com"
  parentRefs:
  - name: http
    namespace: kgateway-system
  rules:
  - matches:
    - path:
        type: Exact
        value: /lambda/prod
    backendRefs:
    - name: lambda
      kind: Upstream
      group: gateway.kgateway.dev
      namespace: kgateway-system
      filters:
      - type: ExtensionRef
        extensionRef:
          group: gateway.kgateway.dev
          kind: RoutePolicy
          name: my-prod-lambda-function
  - matches:
    - path:
        type: Exact
        value: /lambda/dev
    backendRefs:
    - name: lambda
      kind: Upstream
      group: gateway.kgateway.dev
      namespace: kgateway-system
      filters:
      - type: ExtensionRef
        extensionRef:
          group: gateway.kgateway.dev
          kind: RoutePolicy
          name: my-dev-lambda-function
```

### Plugin

The AWS Lambda plugin will be implemented in the `internal/kgateway/extensions2/plugins/upstream` directory. At a high-level, the following changes will be made:

1. Configure the lambda ARN in the [upstream HTTP filter](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/aws_lambda_filter#configuration-as-an-upstream-http-filter).
2. Configure a "dummy" lambda ARN in the [listener filter](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/aws_lambda_filter#configuration-as-a-listener-filter).

The listener filter is responsible for configuring how to authenticate the request to the lambda function. The upstream filter is responsible for configuring each lambda function, how to invoke it, etc. Note, we provide a "dummy" lambda ARN in the listener filter to satisfy the validation logic and to ensure that translator is idempotent (i.e. we don't override the lambda ARN for each route policy) by providing a default value.

This approach was prototyped in the [feat/aws-lambda](https://github.com/timflannagan/kgateway/tree/feat/aws-lambda) branch.

### Authentication Methods

Initial implementation focuses on static credentials for simplicity and ease of testing:

1. **Static Credentials** (Initial Implementation):
   - Credentials stored in Kubernetes secrets
   - Simple to implement and test
   - Suitable for development and testing
2. **Future Authentication Methods**:
   - IRSA (IAM Roles for Service Accounts)
   - Web Identity Token authentication
   - AWS STS token exchange
   - Role chaining for cross-account access

The authentication interface is designed to be extensible, allowing for additional methods to be added as needed.

## Testing

### LocalStack Integration

Testing AWS Lambda integration uses [LocalStack](https://github.com/localstack/localstack), a local AWS emulator that provides a fully functional local AWS cloud stack. This will allows us to test the integration without having to deploy to AWS account.

#### Test Environment Setup

1. **LocalStack Deployment**:
   ```bash
   # Deploy LocalStack to test cluster
   helm repo add localstack-repo https://helm.localstack.cloud
   helm install localstack localstack-repo/localstack
   ```
2. **Test Lambda Functions**:
   - Deploy sample Lambda functions to LocalStack
   - Functions include basic math operations and echo services
   - Provides predictable test cases
3. **Configuration Testing**:
   - Test Upstream configuration with LocalStack endpoints
   - Verify credential handling
   - Test function invocation modes

See the [aws-lambda-testing](https://github.com/timflannagan/aws-lambda-testing) repository for a complete example of how this could be integrated into the project.

## Alternatives

### Alternative 1: Encode the lambda ARN directly in the Upstream API

The alternative is focused on encoding the lambda ARN directly in the Upstream API. This is simpler than the proposed solution, but it does not provide the same flexibility for configuration. Additionally, it requires users to define and maintain N Upstreams for each lambda <function, qualifier> pair.

### Alternative 2: Use a synthetic parameter in backendRef filters

The alternative is focused on adopting Gloo's synthetic `Parameter` GVK for lambda configuration approach. While more flexible than the proposed solution, it requires users to define a new `Parameter` GVK for each lambda function and has less stability guarantees compared to a dedicated Kubernetes API.

### Alternative 3: Use envoy-gloo's lambda filter

The alternative is focused more on the implementation details of the proposed solution. Instead of using the upstream Envoy AWS Lambda filter, it uses envoy-gloo's lambda filter. This is a custom filter that is not upstream, but has been battle-tested over time. With improvements to the upstream Envoy AWS Lambda filter, there's no longer any feature gaps between the two approaches, and adopting the upstream equivalent will lead to a more maintainable solution.
